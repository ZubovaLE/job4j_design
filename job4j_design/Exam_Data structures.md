# Экзамен. Структуры данных и алгоритмы

## Оглавление

1. [Что такое generic?](#1-Что-такое-generic)
2. [Что такое wild cards?](#2-Что-такое-wild-cards)
3. [Что такое bound wild cards?](#3-Что-такое-bound-wild-cards)
4. [Что такое unbounded wild cards?](#4-Что-такое-unbounded-wild-cards)
5. [Где хранится информация про Generics?](#5-Где-хранится-информация-про-Generics)
6. [Как можно получить тип Generics?](#6-Как-можно-получить-тип-Generics)
7. [Что такое итератор?](#7-Что-такое-итератор)
8. [Что такое коллекции?](#8-Что-такое-коллекции)
9. [Назовите базовые интерфейсы коллекций?](#9-Назовите-базовые-интерфейсы-коллекций)
10. [Расскажите реализации интерфейса List?](#10-Расскажите-реализации-интерфейса-List)
11. [Расскажите реализации интерфейса Set?](#11-Расскажите-реализации-интерфейса-Set)
12. [Расскажите реализации интерфейса Map?](#12-Расскажите-реализации-интерфейса-Map)
13. [Отличие ArrayList от LinkedList?](#13-Отличие-ArrayList-от-LinkedList)
14. [Отличие Set от List?](#14-Отличие-Set-от-List)
15. [Расскажите про методы Object hashCode и equals?](#15-Расскажите-про-методы-Object-hashCode-и-equals)
16. [Расскажите про реализации Map?](#16-Расскажите-про-реализации-Map)
17. [Расскажите, что такое коллизии в Map? Как с ними бороться?](#17-Расскажите-что-такое-коллизии-в-Map-Как-с-ними-бороться)
18. [Расскажите, что такое анализ алгоритма?](#18-Расскажите-что-такое-анализ-алгоритма)
19. [Какая временная сложность алгоритмов (O-нотация) добавления, замены и удаления в каждой из коллекций? С чем связаны отличия?](#19-Какая-временная-сложность-алгоритмов-O-нотация-добавления-замены-и-удаления-в-каждой-из-коллекций-С-чем-cвязаны-отличия)
20. [Расскажите реализации данных очередей и стеков.](#20-Расскажите-реализации-данных-очередей-и-стеков)
21. [Расскажите про реализации деревьев.](#21-Расскажите-про-реализации-деревьев)
22. [Что такое loadFactor?](#22-Что-такое-loadFactor)

## 1 Что такое generic?

generics (**обобщения**) - это параметризованные типы.  
Такие типы позволяют объявлять классы, интерфейсы и методы, где тип данных, которыми они оперируют, указан в виде
параметра. Классы, интерфейсы и методы, оперирующие параметризованными типами, называются **обобщёнными**.  
На обобщения можно задавать ограничения: какой класс должен расширять подставляемый параметр или какие интерфейсы
реализовывать.

Основное назначение обобщений - более сильная проверка типов во время компиляции и устранение необходимости явного
приведения. Обобщения внесли в язык безопасность типов. Ошибка компиляции - это лучше, чем исключение ClassCastException
в связи с неправильным приведением типов во время выполнения. После компиляции какая-либо информация об обобщениях
стирается. Это называется "Стиранием типов".

[К оглавлению &#8593;](#Оглавление)

## 2 Что такое wild cards?

WildCard (обозначается <?> - неизвестный тип) - подстановочные типы или маски - используются в сигнатуре методов, но для
параметризации класса - _**нет**_!   
Может быть использован в сочетании с ключевыми словами extends и super. Wildcards удобно использовать для объявления
переменных и параметров методов совместно с классами из Java Collection Framework.

[К оглавлению &#8593;](#Оглавление)

## 3 Что такое bound wild cards?

**Bounded Wildcard** - ограниченный wildcard - Wildcard, который ограничен сверху — <? extends А> или снизу — <? super
А>

_Upper Bounded Wildcard_ - ограничение сверху - такой подход используется, если метод, который нужно реализовать,
использует определенный тип и все его подтипы. В этом случае записывается конструкция <? extends A>. Следовательно,
суперкласс объявляет верхнюю границу включительно.

_Lower bounded Wildcard_ - ограничение снизу (ограничивает неизвестный тип определенным типом или супертипом этого типа)
. В этом случае записывается конструкция <? super A>. Это означает, что вместо «?» можно подставить A или любой
класс-предок А.

[К оглавлению &#8593;](#Оглавление)

## 4 Что такое unbounded wild cards?

Unbounded wild cards - wildcard без какого-либо ограничения

[К оглавлению &#8593;](#Оглавление)

## 5 Где хранится информация про Generics?

Только в исходном коде до момента компиляции. Существует только одна ситуация, когда универсальный тип доступен во время
выполнения - это когда универсальный тип является частью сигнатуры класса.

[К оглавлению &#8593;](#Оглавление)

## 6 Как можно получить тип Generics?

Такая возможность есть - даже несмотря на то, что это используется довольно редко. Существует только одна ситуация,
когда универсальный тип доступен во время выполнения - это когда универсальный тип является частью сигнатуры класса
подобным образом:

```java
public class FloatList extends ArrayList<Float> {

}
```

Теперь мы можем узнать что класс ArrayList (а, соответственно, и класс FloatList) был параметризован классом Float
следующим образом:

```java 
public class Test { public static void main(String[] args) { ArrayList<Float> listOfNumbers = new FloatList();
Class actual = listOfNumbers.getClass(); ParameterizedType type = (ParameterizedType) actual.getGenericSuperclass();
System.out.println(type); Class parameter = (Class) type.getActualTypeArguments()[0]; System.out.println(parameter); } }
```

[К оглавлению &#8593;](#Оглавление)

## 7 Что такое итератор?

Итератор - это шаблон проектирования, который позволяет последовательно получить элементы набора данных.  
Шаблон итератор описывается интерфейсом - java.util.Iterator. Шаблон итератор используется в коллекциях, базах данных,
чтении файлов.

[К оглавлению &#8593;](#Оглавление)

## 8 Что такое коллекции?

Коллекция - это класс, основная цель которого - хранить набор однородных элементов. В коллекции Java хранятся только
ссылки/указатели и ничего более. Инструменты для работы с такими структурами в Java содержатся в Java Collections
Framework. Фреймворк состоит из интерфейсов, их реализаций и утилитарных классов для работы со списками:
сортировки, поиска, преобразования.

[К оглавлению &#8593;](#Оглавление)

## 9 Назовите базовые интерфейсы коллекций?

+ Collection
+ Map

[К оглавлению &#8593;](#Оглавление)

## 10 Расскажите реализации интерфейса List?

+ LinkedList - класс, который реализует два интерфейса - List и Deque - благодаря чему обеспечивается возможность
  создавать двунаправленные (те, которые можно обходить в обоих направлениях) очереди из любых (в том числе и null)
  элементов. Каждый объект помещенный в связанный список, является узлом (для этого используются объекты вложенного
  класса Node). Каждый узел содержит в себе элемент который мы добавили, а также ссылку на предыдущий и следующий узлы
+ ArrayList - в основе реализации этого класса лежит динамический массив (ArrayList может менять свой размер во время
  исполнения программы, и при этом нет строгого требования указывать размерность при создании объекта ArrayList).

[К оглавлению &#8593;](#Оглавление)

## 11 Расскажите реализации интерфейса Set?

В коллекции, реализующей интерфейс Set, собраны уникальные объекты

+ HashSet - инкапсулирует в себе объект HashMap, поэтому для хранения используется хэш-таблица. При этом ключами в
  таблице будут значения, которые мы поместили в HashSet, а значения, которые соответствуют этим ключам - будут значения
  null.
+ LinkedHashSet - расширяет HashSet, позволяет получать элементы в порядке их добавления, но требует больше памяти.
+ TreeSet - структура данных в виде дерева, в котором все объекты хранятся в отсортированном по возрастанию порядке.
  TreeSet инкапсулирует в себе TreeMap, который в свою очередь использует сбалансированное бинарное красно черное дерево
  для хранения элементов.

[К оглавлению &#8593;](#Оглавление)

## 12 Расскажите реализации интерфейса Map?

+ HashMap - основан на хэш-таблицах. Ключи и значения могут быть любых типов, в том числе и null. Данная реализация не
  дает гарантий относительно порядка элементов
+ LinkedHashMap - расширяет класс HashMap. Он создает связный список элементов в карте, расположенных в том порядке, в
  котором они вставлялись.
+ TreeMap - создает коллекцию, которая для хранения элементов применяет дерево. Объекты сохраняются в отсортированном
  порядке по возрастанию. Время доступа и извлечения элементов достаточно мало, что делает класс TreeMap блестящим
  выбором для хранения больших объемов отсортированной информации

[К оглавлению &#8593;](#Оглавление)

## 13 Отличие ArrayList от LinkedList?

ArrayList - реализация List интерфейса на основе динамически изменяемого массива, поэтому при вставке элемента в
середину, приходится сначала сдвигать на один все элементы после него, а уже затем в освободившееся место вставлять
новый элемент. LinkedList - реализация List интерфейса на основе двухстороннего связанного списка, состоящего из
последовательных узлов, каждый из которых предназначен для хранения объекта определенного при создании типа и хранит в
себе ссылки на предыдущий и последующие узлы.

ArrayList

- быстрый доступ к элементам по индексу (O(1)), но доступ к элементам по значению за линейное время (O(n));
- реализации вставки и удаления элементов из "середины" списка - достаточно медленные и тяжелые;

LinkedList:

- Обеспечивает быстрое (O(1)) добавление и удаление первого и последнего элемента. Также быстро выполняются операции
  вставки и удаления элементов в середину списка(выносим за скобки поиск позиции элемента, который осуществляется за
  линейное время).
- Поиск элемента по значению и индексу осуществляется за линейное время (O(n)).

ArrayList - в большинстве случаев лучшая возможная реализация List интерфейса по потреблению памяти и
производительности. В крайне редких случаях, когда требуются частые вставки в начало или середину списка с очень малым
количеством перемещений по списку, LinkedList будет выигрывать в производительности.

LinkedList, как правило, требует больше памяти и хуже по производительности, чем ArrayList. Имеет смысл использовать в
случаях, когда часто требуется вставка/удаление в середину списка с минимальными перемещениями по списку.

Таким образом, если добавлять и удалять элементы с произвольными индексами в списке нужно чаще, чем итерироваться по
нему, то лучше использовать LinkedList. В остальных случаях — ArrayList.

[К оглавлению &#8593;](#Оглавление)

## 14 Отличие Set от List?

+ Set хранится в неупорядоченном виде и не допускает дублирования значений. List используется для упорядоченного
  хранения элементов и допускает дублирование значений.
+ К элементам Set нельзя получить доступ с помощью позиции индекса, а к элементам List можно получить доступ с помощью
  позиции индекса.

[К оглавлению &#8593;](#Оглавление)

## 15 Расскажите про методы Object hashCode и equals?

Существует контракт: если переопределен hashCode(), то нужно обязательно переопределить equals(), потому что может
возникнуть ситуация, когда для разных объектов получаются одинаковые хеш-значения. Тогда вызывается метод equals,
благодаря которому становится понятно, равны эти объекты или нет

Есть правила:

- Если объекты **равны по hashCode()**, то они **не обязательно равны по equals()**
- Если объекты **равны по equals()**, то они **обязательно равны по hashCode()**
- Если объект **не равны по hashCode()**, то они точно **не равны по equals()**
- Если объекты **не равны по equals()**, то **возможно совпадение их hashCode()**

[К оглавлению &#8593;](#Оглавление)

## 16 Расскажите про реализации Map?

Наиболее часто используемые реализации – это HashMap и TreeMap.

- HashMap основан на хеш-таблицах, отображает ключ и значение, не гарантирует, что элементы будут храниться в порядке
  добавления. Кроме того, не гарантирует, что порядок элементов не будет меняться со временем.
- LinkedHashMap - расширяет класс HashMap. Он создает связный список элементов в карте, расположенных в том порядке, в
  котором они вставлялись.
- TreeMap также отображает ключ и значение, но гарантирует хранение элементов в порядке возрастания или же в
  соответствии с заданным компаратором.

[К оглавлению &#8593;](#Оглавление)

## 17 Расскажите, что такое коллизии в Map? Как с ними бороться?

Коллизия - эта такая ситуация, при которой для двух разных объектов (ключей) мы получаем один и тот же бакет.

Могут быть следующие причины коллизий:

1. относительно получения бакета
2. относительно hash() функции
3. относительно hashCode()

Если получение индекса мы изменить не можем, то hash() и hashCode() нам подвластны. Алгоритмы действий в этой ситуации
называются методами разрешения коллизий. Они бывают следующие:

1. _Открытая адресация_  
   Самый простой способ – линейное пробирование.

Например, мы получили хэш i и оказалось, что это место занято. В этом случае делается следующее: запускается цикл и
просматриваются ячейки, индексы которых вычисляются как ( i + k ) % length, где i – исходный хэш, а length – это размер
таблицы

2. _Метод цепочек_

У открытой адресации есть недостатки - возможна потеря данных, т.к. возможно зацикливание, поэтому число проб
ограничивают. Если сделать его большим, то программа будет работать дольше, а если малым, то возможно, что вставка не
произойдет

Как альтернатива существует метод цепочек. Этот метод основан на связных списках, т.е. вместо вставки самих данных
напрямую, вставка идет в список, который хранится по хэшу. В случае коллизии элемент просто вставляется в конец списка.
Чтобы понизить число коллизий, ввели **фактор загрузки**, показывающий максимальное количество элементов, которое может
содержать таблица данного размера. При превышении данного соотношения нужно расширять контейнер.

[К оглавлению &#8593;](#Оглавление)

## 18 Расскажите, что такое анализ алгоритма?

Анализ алгоритма - это определение, сколько времени займет решение данной задачи при помощи данного алгоритма.
Эффективность алгоритма оценивается его временной сложностью.

Временная сложность алгоритма – это функция, позволяющая определить, как быстро увеличивается время работы алгоритма с
увеличением объёма данных.

Наиболее часто встречающиеся классы сложности:

+ O(1) – константная сложность (т.е. константное время);
+ О(n) – линейная сложность;
+ О(np) – полиномиальная сложность;
+ О(log(n)) – логарифмическая сложность;
+ O(n*log(n)) – квазилинейная сложность; O(2n) – экспоненциальная сложность;
+ O(n!) – факториальная сложность.

[К оглавлению &#8593;](#Оглавление)

## 19 Какая временная сложность алгоритмов (O-нотация) добавления, замены и удаления в каждой из коллекций? С чем связаны отличия?

Отличие связаны с реализацией данных операций. ArrayList - реализация List интерфейса на основе динамически изменяемого
массива, поэтому при вставке элемента в середину, приходится сначала сдвигать на один все элементы после него, а уже
затем в освободившееся место вставлять новый элемент. LinkedList - реализация List интерфейса на основе двухстороннего
связанного списка, состоящего из последовательных узлов, каждый из которых предназначен для хранения объекта
определенного при создании типа и хранит в себе ссылки на предыдущий и последующие узлы. Поэтому при удалении или
добавлении меняются лишь ссылки у узлов.

ArrayList: поиск по индексу - O(1), поиск по значению - O(n), вставка - O(n), удаление - O(n).

LinkedList: поиск по индексу - O(n), поиск по значению - O(n), вставка - O(1), удаление - O(1).

Деревья для всех операций - O(log(n)).

Коллекции на основе хеш-таблиц для всех операций - O(1), если не считать коллизии.

[К оглавлению &#8593;](#Оглавление)

## 20 Расскажите реализации данных очередей и стеков.

+ Queue (FIFO) - одностороняя очередь, элементы можно получить в том порядке, в котором они были добавлены.
+ Dequeue - двусторонняя очередь, можно вставлять/получать элементы из начала и конца.
+ Stack (LIFO) - стек, можно получить только последний элемент.

  [К оглавлению &#8593;](#Оглавление)

## 21 Расскажите про реализации деревьев.

+ TreeMap - обеспечивает упорядочение по _ключам_. TreeMap основан на сбалансированном красно-черном дереве, которое
  гарантирует логарифмический рост высоты дерева от числа узлов. Элементы здесь упорядочены (в естественном или заданном
  при создании порядке) в каждый момент времени. При этом вставка и удаление более затратны, чем в случае с HashMap.

+ TreeSet - основан на сбалансированном бинарном дереве, в результате элементы упорядочены по возрастанию. Можно
  управлять порядком при помощи компаратора.

null-значения **запрещены** в TreeMap и TreeSet, так как это упорядоченные структуры, которые при добавлении нового
элемента используют сравнение.

[К оглавлению &#8593;](#Оглавление)

## 22 Что такое loadFactor?

loadFactor - фактор загрузки - показывает, при каком отношении количества элементов к размеру хеш-таблицы происходит её
расширение. Оптимальным считается 0.75 (count / capacity >= 0.75, т.е при заполнении таблицы на 75% происходит её
расширение в 2 раза).

[К оглавлению &#8593;](#Оглавление)