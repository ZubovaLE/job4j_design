# Экзамен. Структуры данных и алгоритмы

## Оглавление

1. [Что такое generic?](#1-Что-такое-generic)
2. [Что такое wild cards?](#2-Что-такое-wild-cards)
3. [Что такое bound wild cards?](#3-Что-такое-bound-wild-cards)
4. [Что такое unbounded wild cards?](#4-Что-такое-unbounded-wild-cards)
5. [Где хранится информация про Generics?](#5-Где-хранится-информация-про-Generics)
6. [Как можно получить тип Generics?](#6-Как-можно-получить-тип-Generics)
7. [Что такое итератор?](#7-Что-такое-итератор)
8. [Что такое коллекции?](#8-Что-такое-коллекции)
9. [Назовите базовые интерфейсы коллекций?](#9-Назовите-базовые-интерфейсы-коллекций)
10. [Расскажите реализации интерфейса List?](#10-Расскажите-реализации-интерфейса-List)
11. [Расскажите реализации интерфейса Set?](#11-Расскажите-реализации-интерфейса-Set)
12. [Расскажите реализации интерфейса Map?](#12-Расскажите-реализации-интерфейса-Map)
13. [Отличие ArrayList от LinkedList?](#13-Отличие-ArrayList-от-LinkedList)
14. [Отличие Set от List?](#14-Отличие-Set-от-List)
15. [Расскажите про методы Object hashCode и equals?](#15-Расскажите-про-методы-Object-hashCode-и-equals)
16. [Расскажите про реализации Map?](#16-Расскажите-про-реализации-Map)
17. [Расскажите, что такое коллизии в Map? Как с ними бороться?](#17-Расскажите-что-такое-коллизии-в-Map-Как-с-ними-бороться)
18. [Расскажите, что такое анализ алгоритма?](#18-Расскажите-что-такое-анализ-алгоритма)
19. [Какая временная сложность алгоритмов(O-нотация) добавления, замены и удаления в каждой из коллекций? С чем связаны отличия?](#19-Какая-временная-сложность-алгоритмов-O-нотация-добавления-замены-и-удаления-в-каждой-из-коллекций-С-чем-cвязаны-отличия)
20. [Расскажите реализации данных очередей и стеков.](#20-Расскажите-реализации-данных-очередей-и-стеков)
21. [Расскажите про реализации деревьев.](#21-Расскажите-про-реализации-деревьев)
22. [Что такое loadFactor?](#22-Что-такое-loadFactor)

## 1 Что такое generic?

generics (**обобщения**) - это параметризованные типы.  
Такие типы позволяют объявлять классы, интерфейсы и методы, где тип данных, которыми они оперируют, указан в виде
параметра. Классы, интерфейсы и методы, оперирующие параметризованными типами, называются **обобщёнными**.  
На обобщения можно задавать ограничения: какой класс должен расширять подставляемый параметр или какие интерфейсы
реализовывать.

Основное назначение обобщений - более сильная проверка типов во время компиляции и устранение необходимости явного
приведения. Обобщения внесли в язык безопасность типов. Ошибка компиляции - это лучше, чем исключение ClassCastException
в связи с неправильным приведением типов во время выполнения. После компиляции какая-либо информация об обобщениях
стирается. Это называется "Стиранием типов".

[К оглавлению &#8593;](#Оглавление)

## 2 Что такое wild cards?

WildCard (обозначается <?> - неизвестный тип) - подстановочные типы или маски - используются в сигнатуре методов, но для
параметризации класса - _**нет**_!   
Может быть использован в сочетании с ключевыми словами extends и super. Wildcards удобно использовать для объявления
переменных и параметров методов совместно с классами из Java Collection Framework.

[К оглавлению &#8593;](#Оглавление)

## 3 Что такое bound wild cards?

**Bounded Wildcard** - ограниченный wildcard - Wildcard, который ограничен сверху — <? extends А> или снизу — <? super
А>

_Upper Bounded Wildcard_ - ограничение сверху - такой подход используется, если метод, который нужно реализовать,
использует определенный тип и все его подтипы. В этом случае записывается конструкция <? extends A>. Следовательно,
суперкласс объявляет верхнюю границу включительно.

_Lower bounded Wildcard_ - ограничение снизу (ограничивает неизвестный тип определенным типом или супертипом этого типа)
. В этом случае записывается конструкция <? super A>. Это означает, что вместо «?» можно подставить A или любой
класс-предок А.

[К оглавлению &#8593;](#Оглавление)

## 4 Что такое unbounded wild cards?

Unbounded wild cards - wildcard без какого-либо ограничения

[К оглавлению &#8593;](#Оглавление)

## 5 Где хранится информация про Generics?

Только в исходном коде до момента компиляции. Существует только одна ситуация, когда универсальный тип доступен во время
выполнения - это когда универсальный тип является частью сигнатуры класса.

[К оглавлению &#8593;](#Оглавление)

## 6 Как можно получить тип Generics?

Такая возможность есть - даже несмотря на то, что это используется довольно редко. Существует только одна ситуация,
когда универсальный тип доступен во время выполнения - это когда универсальный тип является частью сигнатуры класса
подобным образом:

```java
public class FloatList extends ArrayList<Float> {

}
```

Теперь мы можем узнать что класс ArrayList (а, соответственно, и класс FloatList) был параметризован классом Float
следующим образом:

```java 
public class Test { public static void main(String[] args) { ArrayList<Float> listOfNumbers = new FloatList();
Class actual = listOfNumbers.getClass(); ParameterizedType type = (ParameterizedType) actual.getGenericSuperclass();
System.out.println(type); Class parameter = (Class) type.getActualTypeArguments()[0]; System.out.println(parameter); } }
```

[К оглавлению &#8593;](#Оглавление)

## 7 Что такое итератор?

Итератор - это шаблон проектирования, который позволяет последовательно получить элементы набора данных.  
Шаблон итератор описывается интерфейсом - java.util.Iterator. Шаблон итератор используется в коллекциях, базах данных,
чтении файлов.

[К оглавлению &#8593;](#Оглавление)

## 8 Что такое коллекции?

Коллекция - это группа объектов

[К оглавлению &#8593;](#Оглавление)

## 9 Назовите базовые интерфейсы коллекций?

+ Collection
+ Map

[К оглавлению &#8593;](#Оглавление)

## 10 Расскажите реализации интерфейса List?

LinkedList ArrayList
[К оглавлению &#8593;](#Оглавление)

## 11 Расскажите реализации интерфейса Set?

В коллекции, реализующей интерфейс Set, собраны уникальные объекты

+ HashSet - инкапсулирует в себе объект HashMap, поэтому для хранения используется хэш-таблица. При этом ключами в
  таблице будут значения которые мы поместили в HashSet, а значения, которые соответствуют этим ключам - будут значения
  null.
+ LinkedHashSet - расширяет HashSet, позволяет получать элементы в порядке их добавления, но требует больше памяти.
+ TreeSet - структура данных в виде дерева, в котором все объекты хранятся в отсортированном по возрастанию порядке.
  TreeSet инкапсулирует в себе TreeMap, который в свою очередь использует сбалансированное бинарное красно черное дерево
  для хранения элементов.

[К оглавлению &#8593;](#Оглавление)

## 12 Расскажите реализации интерфейса Map?

+ HashMap - основан на хэш-таблицах. Ключи и значения могут быть любых типов, в том числе и null. Данная реализация не
  дает гарантий относительно порядка элементов
+ LinkedHashMap - расширяет класс HashMap. Он создает связный список элементов в карте, расположенных в том порядке, в
  котором они вставлялись.
+ TreeMap - создает коллекцию, которая для хранения элементов применяет дерево. Объекты сохраняются в отсортированном
  порядке по возрастанию. Время доступа и извлечения элементов достаточно мало, что делает класс TreeMap блестящим
  выбором для хранения больших объемов отсортированной информации

[К оглавлению &#8593;](#Оглавление)

## 13 Отличие ArrayList от LinkedList?

ArrayList - список на основе массива, а LinkedList - список, состоящий из последовательных узлов, каждый из которых
предназначен для хранения объекта определенного при создании типа.

ArrayList

- быстрый доступ к элементам по индексу (O(1)), но доступ к элементам по значению за линейное время (O(n));
- реализации вставки и удаления элементов из "середины" списка - достаточно медленные и тяжелые;

LinkedList:

- Обеспечивает быстрое (O(1)) добавление и удаление первого и последнего элемента. Также быстро выполняются операции
  вставки и удаления элементов в середину списка(выносим за скобки поиск позиции элемента, который осуществляется за
  линейное время).
- Поиск элемента по значению и индексу осуществляется за линейное время (O(n)).

[К оглавлению &#8593;](#Оглавление)

## 14 Отличие Set от List?

В Set хранятся уникальные элементы (то есть здесь отсутствуют дубликаты)
Set основан на хеш-таблицах

List позволяет хранить любые данные, в том числе null и дубликаты.

[К оглавлению &#8593;](#Оглавление)

## 15 Расскажите про методы Object hashCode и equals?

[К оглавлению &#8593;](#Оглавление)

## 16 Расскажите про реализации Map?

[К оглавлению &#8593;](#Оглавление)

## 17 Расскажите, что такое коллизии в Map? Как с ними бороться?

Коллизия - эта такая ситуация, при которой для двух разных объектов (ключей) мы получаем один и тот же бакет.

[К оглавлению &#8593;](#Оглавление)

## 18 Расскажите, что такое анализ алгоритма?

[К оглавлению &#8593;](#Оглавление)

## 19 Какая временная сложность алгоритмов(O-нотация) добавления, замены и удаления в каждой из коллекций? С чем связаны отличия?

[К оглавлению &#8593;](#Оглавление)

## 20 Расскажите реализации данных очередей и стеков.

[К оглавлению &#8593;](#Оглавление)

## 21 Расскажите про реализации деревьев.

[К оглавлению &#8593;](#Оглавление)

## 22 Что такое loadFactor?

loadFactor - фактор загрузки- показывает, при каком отношении количества элементов к размеру хеш-таблицы происходит её
расширение. Оптимальным считается 0.75 (count / capacity >= 0.75, т.е при заполнении таблицы на 75% происходит её
расширение в 2 раза).

[К оглавлению &#8593;](#Оглавление)