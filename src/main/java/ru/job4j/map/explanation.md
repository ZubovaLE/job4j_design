# Пояснения к классам User, Users, UserWithHashCode, UserWithEquals, UserWithEqualsAndHashCode

## 1 Создать модель User

Создала класс User. Добавила конструктор и геттеры, потому что дальше я буду расширять этот класс и мне нужны будут
значения полей при переопределении методов equals и hashCode.

Создала дополнительно класс Users, где в методе main создала для разных классов (производных от User) по 2 объекта с
одинаковыми полями. Далее добавляла эти объекты в качестве ключей в карту Map<User, Object>. Таким образом, я проверяла,
будут ли добавляться объекты с одинаковыми по смыслу ключами в карту Map.

## 2 Без переопределения equals и hashCode

1. В классе User не переопределяла методы equals() и hasCode();
2. В классе Users создала два объекта User, которые имеют одинаковые поля.
3. Создала карту Map <User, Object>
4. Добавила туда две пары, где в качестве ключей использовала созданные объекты User, а в качестве значений – просто new
   Object() . Вывела карту на печать. В выводе я увидела, что обе пары ключ-значение были добавлены в карту, несмотря на
   смысловую идентичность ключей.
5. Ответы на вопросы:  
   5.1. Объекты попали в один бакет или в разные?   
   *С большей вероятностью объекты попали в разные бакеты, так как более вероятно, что метод hashCode вернул разные
   хеш-коды для ключей, метод hash() вернул разные хеши, а вычисление индекса вернуло разные значения. Но не исключено
   возникновение коллизий (когда для разных ключей получаем один и тот же бакет, или индекс):*

+ *Хеш-коды могли совпасть, тогда хеши тоже совпадут*
+ _Хеш-коды разные, но хеши могли совпасть_
+ _Вычисление индекса привело к одинаковым значениям_  
  5.2. Вызывался ли в этом случае equals() у объектов User или нет? Объяснить почему.  
  _Нет, если ключи имеют разные хеши и вычисление индекса даёт разные значения. Если же возникла коллизия, метод
  equals() вызывается, но в нашем случае equals() вернёт false, потому что он реализован по умолчанию, а такая
  реализация возвращает true только в случае, когда передаваемые ссылки ссылаются на один объект. Поэтому в бакет будут
  занесены оба объекта последовательно друг за другом_.

## 3 Переопределить только hashCode

1. Создала класс UserWithHashCode, который расширяет класс User, и переопределила в нём метод hashCode(). Метод equals()
   остался по умолчанию.
2. В классе Users создала два объекта UserWithHashCode, которые имеют одинаковые поля, и добавила их в качестве ключей в
   новую карту Map<User, Object>.
3. При выводе карты на печать увидела, что обе пары ключ-значение были добавлены, хотя по смыслу ключи равны.
4. Ответы на вопросы:  
   4.1. Объекты попали в один бакет или в разные?  
   _Объекты попали в один бакет, потому что индекс (бакет) вычисляется на основе хеша, а хеш – на основе метода
   hashCode(). Мы переопределили метод hashCode(), и он для вычисления хеш-кода использует значения полей ключа. Поля
   обоих ключей одинаковы, а значит, вычисленные хеш-коды будут одинаковы, тогда хеши будут равны и вычисление индекса
   вернёт одинаковые значения._   
   4.2. Вызывался ли в этом случае equals() у объектов User или нет? Объяснить почему.  
   _Да, мы получаем одинаковые индексы за счёт того, что ключи имеют одинаковые хеши. Поэтому возникает коллизия, из-за
   чего вызывается метод equals() для проверки равенства ключей. Но equals() вернёт false, так как ключи имеют разные
   ссылки, поэтому обе пары будут добавлены в один бакет друг за другом._

## 4 Переопределить только equals

1. Создала класс UserWithEquals, который расширяет класс User, и переопределила в нём метод equals(), метод hasCode()
   оставила по умолчанию.
2. В классе Users создала два объекта UserWithEquals, которые имеют одинаковые поля, и добавила их в качестве ключей в
   новую карту Map<User, Object>.
3. При выводе карты на печать видно, что оба ключа попали в карту.
4. Ответы на вопросы:  
   4.1. Объекты попали в один бакет или в разные?  
   _Вероятнее всего, объекты попали в разные бакеты (более вероятно, что хеши ключей различны, а значит, вычисление
   индекса даёт разные значения). Другой вариант – возникла коллизия, поэтому при попытке добавить новую пару
   ключ-значение вызвался метод equals() для ключей. Метод вернул true (т.к мы его переопределили), а значит, текущее
   значение в бакете, соответствующее данному ключу, заменено на новое._  
   4.2. Вызывался ли в этом случае equals() у объектов User или нет? Объяснить почему   
   _Если коллизии не было, то метод не вызывался. Если коллизия была, то метод вызывался для проверки равенства ключей и
   возвратил true._

## 5 Переопределить и equals и hashCode

1. Создала класс UserWithEqualsAndHashCode, который расширяет класс User, и переопределила в нём equals() и hashCode().
2. Создала два объекта UserWithEqualsAndHashCode, которые имеют одинаковые поля и добавила их в новую Map<User, Object>.
   Вывела карту на печать. _При выводе видно, что в карту была добавлена только она пара ключ-значение, потому что в
   случае переопределения обоих методов equals и hashCode данные ключи считаются одинаковыми, поэтому вызов put()
   приводит к замене имеющегося значение на новое._
